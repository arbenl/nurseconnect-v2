1) Add Zod everywhere data crosses a boundary

import { z } from 'zod';

export const Role = z.enum(['admin', 'nurse', 'staff']);
export const UserId = z.string().min(1, 'uid required');

export const UserProfile = z.object({
  uid: UserId,
  email: z.string().email(),
  displayName: z.string().min(1),
  roles: z.array(Role).nonempty().default(['staff']),
  createdAt: z.string(), // ISO date
  updatedAt: z.string().optional(),
});
export type UserProfile = z.infer<typeof UserProfile>;

// For signup/login forms
export const Credentials = z.object({
  email: z.string().email(),
  password: z.string().min(8),
  displayName: z.string().min(1).optional(), // signup only
});

// apps/web/src/app/api/user/create/route.ts
import { NextResponse } from 'next/server';
import { Credentials, UserProfile } from '@nurseconnect-v2/contracts/user';
import { z } from 'zod';

export async function POST(req: Request) {
  try {
    const data = await req.json();
    const { email, password, displayName } = Credentials.parse(data);
    // …create auth user, then:
    const profile = UserProfile.parse({
      uid: createdUid,
      email,
      displayName: displayName ?? '',
      roles: ['staff'],
      createdAt: new Date().toISOString(),
    });
    // write profile (server-side admin SDK only)
    return NextResponse.json({ ok: true, profile }, { status: 201 });
  } catch (err) {
    if (err instanceof z.ZodError) {
      return NextResponse.json({ ok: false, errors: err.errors }, { status: 400 });
    }
    return NextResponse.json({ ok: false, error: 'server_error' }, { status: 500 });
  }
}

Guard Firestore reads/writes
	•	Parse documents on read with UserProfile.parse(snap.data()).
	•	Parse payloads before write.

⸻

2) First-class forms: react-hook-form + Zod resolver

// apps/web/src/app/(auth)/signup/page.tsx
'use client';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { Credentials } from '@nurseconnect-v2/contracts/user';
import type { z } from 'zod';

type FormData = z.infer<typeof Credentials>;

export default function Signup() {
  const { register, handleSubmit, formState: { errors, isSubmitting } } =
    useForm<FormData>({ resolver: zodResolver(Credentials) });

  const onSubmit = async (data: FormData) => { /* call /api/user/create */ };

  return (
    <form onSubmit={handleSubmit(onSubmit)} className="space-y-4">
      <input {...register('email')} type="email" />
      {errors.email && <p>{errors.email.message}</p>}
      <input {...register('password')} type="password" />
      {errors.password && <p>{errors.password.message}</p>}
      <button disabled={isSubmitting}>Sign up</button>
    </form>
  );
}

3) TanStack Query for server state

// apps/web/src/components/query-provider.tsx
'use client';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { useState } from 'react';

export default function QueryProvider({ children }: { children: React.ReactNode }) {
  const [client] = useState(() => new QueryClient());
  return <QueryClientProvider client={client}>{children}</QueryClientProvider>;
}

Fetching Example

import { useQuery } from '@tanstack/react-query';

export function useUserProfile(uid: string) {
  return useQuery({
    queryKey: ['user', uid],
    queryFn: async () => {
      const res = await fetch(`/api/user/${uid}`);
      const json = await res.json();
      // validate response
      return UserProfile.parse(json.profile);
    },
    staleTime: 30_000,
    retry: 1,
  });
}

4) Rate limit auth-sensitive endpoints

Option A (dev & CI safe): in-memory (per process)

// apps/web/src/lib/rateLimit.ts
const buckets = new Map<string, { count: number; reset: number }>();
export function allow(ip: string, limit = 10, windowMs = 60_000) {
  const now = Date.now();
  const b = buckets.get(ip) ?? { count: 0, reset: now + windowMs };
  if (now > b.reset) { b.count = 0; b.reset = now + windowMs; }
  b.count++; buckets.set(ip, b);
  return b.count <= limit;
}

Use in routes:
const ip = req.headers.get('x-forwarded-for') ?? 'local';
if (!allow(ip, 20, 60_000)) return NextResponse.json({ ok:false, error:'rate_limited' }, { status:429 });

Option B (prod): Upstash Redis
	•	Add middleware or per-route limiter using their SDK. (Can wire via OPS later.)

5) Security headers via middleware

// apps/web/src/middleware.ts (augment existing)
import { NextResponse } from 'next/server';

export const config = { matcher: ['/((?!_next/static|_next/image|favicon.ico).*)'] };

export default function harden(req: Request) {
  const res = NextResponse.next();
  res.headers.set('X-Content-Type-Options', 'nosniff');
  res.headers.set('X-Frame-Options', 'DENY');
  res.headers.set('Referrer-Policy', 'no-referrer');
  res.headers.set('Permissions-Policy', 'camera=(), microphone=(), geolocation=()');
  // CSP later (once assets/analytics are known)
  return res;
}

Keep your NextAuth middleware for /dashboard protection as is; if you need both, compose them (e.g., call next-auth/middleware first, then add headers if it returned undefined).

6) Fast structured logging

Logger

// apps/web/src/lib/log.ts
import pino from 'pino';
export const log = pino({ level: process.env.LOG_LEVEL ?? 'info', base: undefined });

Use in API routes/server actions:

log.info({ route: 'user/create', uid }, 'user created');
log.warn({ ip }, 'rate limit exceeded');

7) Consistent error surface

// apps/web/src/lib/error.ts
import type { ZodError } from 'zod';
export function zodToFieldErrors(err: ZodError) {
  return err.issues.map(i => ({ path: i.path.join('.'), message: i.message }));
}

Use in API responses and render near fields (RHForm’s errors or your own).

8) Tests to lock contracts

Schema contract tests

// packages/contracts/test/user.schema.test.ts
import { describe, it, expect } from 'vitest';
import { UserProfile } from '../src/user';

describe('UserProfile schema', () => {
  it('accepts valid payload', () => {
    const p = UserProfile.parse({
      uid: 'abc', email: 'a@b.com', displayName: 'A', roles: ['staff'], createdAt: new Date().toISOString()
    });
    expect(p.uid).toBe('abc');
  });
  it('rejects bad email', () => {
    expect(() => UserProfile.parse({ uid: '1', email: 'no', displayName: 'x', roles:['staff'], createdAt: '2020-01-01T00:00:00Z' }))
      .toThrowError();
  });
});

Form render smoke tests (keep them light; you already run emulator tests).

9) Perf nudges
	•	Use next/font with display: 'swap' and subset your fonts.
	•	Wrap large client components with dynamic(() => import(...), { ssr: false }) if SSR doesn’t help.
	•	Prefer server components for static/SEO pages; keep client components thin.
	•	For Firestore reads that don’t need per-request auth, consider Route Handlers on the server + Query caching (revalidate tags/paths later).

Commands checklist (you can paste and run)

# deps
pnpm -w add zod react-hook-form @hookform/resolvers @tanstack/react-query pino

# add contract tests (optional quick win)
pnpm -w vitest run

# run your CI phase with emulators
pnpm run ci:phase


Where this fits with Agents
	•	DEV: adds Zod schemas, RHF form wiring, Query Provider, logging, rate limiter.
	•	QA: adds schema contract tests + basic render tests; keeps emulator smoke.
	•	SECURITY: confirms rate-limit coverage, tightens Firestore rules (owner-only), and reviews headers.
	•	UX (your new agent): refactors auth pages to shadcn/ui + tokens; keeps forms tied to Zod.
	•	OPS (when ready): adds pnpm run lh:ci & axe to CI and turns on size limits (e.g., next build trace artifacts) later.



